Binary Heaps<br><br><ul><li dir="ltr">ordered (linked) list =&gt; O(n)<br></li><li dir="ltr">binary heap =&gt; O(log n)<br><ul><li dir="ltr">min-heap<br><ul><li dir="ltr">smaller number = higher priority<br></li></ul></li><li dir="ltr">max-heap<br><ul><li dir="ltr">smaller number = lower priority<br></li></ul></li></ul></li><li dir="ltr">heap structure property<br><ul><li dir="ltr">almost-complete tree<br></li></ul></li><li dir="ltr">heap order property<br><ul><li dir="ltr">any given node will have a smaller value than anything in its left or right subtrees (anything "below" it)<br></li><li dir="ltr">that is, all nodes have larger values than their parents<br></li><li dir="ltr">therefore findMin() will <i>always</i> be <span style="font-family:monospace">O(1)</span> because the smallest node is the root<br></li></ul></li><li dir="ltr">inserts<br><ul><li dir="ltr">insert performance will <i>always</i> be <span style="font-family:monospace">log(n)</span> because the heap is balanced<br></li><li dir="ltr">inserts happen at the position which will maintain the "almost-complete" property<br><ul><li dir="ltr">on the bottom generation of the heap, insert in the first available slot from the left<br></li><li dir="ltr">only if the bottom generation of the heap is full do we make a new generation<br></li></ul></li><li dir="ltr">after inserting, check the node's parent, grandparent, etc. to make sure the heap order property is satisfied<br></li></ul></li><li dir="ltr">deletes (pops)<br><ul><li dir="ltr">1: swap the first (root) and the last elements of the heap<br><ul><li dir="ltr">decrement size of the heap by one (which essentially removes the now-last, previously-first element)<br></li></ul></li><li dir="ltr">2: bubble down the "new" root<br><ul><li dir="ltr">if min-heap, swap it with the smaller of its two children<br></li><li dir="ltr">if max-heap, swap it with the larger of its two children<br></li></ul></li></ul></li><li dir="ltr">HEAPIFY -Dr. J<br><ul><li dir="ltr">make an array into a heap<br></li><li dir="ltr">Given: n elements in an array<br><ul><li dir="ltr">insert all elements into an almost-complete tree<br></li><li dir="ltr">Go to largest index of a non-leaf = (<span style="font-family:monospace">n/2 - 1</span>) and turn it into a heap:<br><ul><li dir="ltr">if any of the node's children is greater (max-heap) than it or smaller (min-heap) than it, then:<br><ul><li dir="ltr">swap the node with its<br><ul><li dir="ltr">largest child if max-heap<br></li><li dir="ltr">smallest child if min-heap<br></li></ul></li></ul></li></ul></li><li dir="ltr">repeat with the next-largest index of a non-leaf<br></li></ul></li></ul></li><li dir="ltr">heaps are a very efficient way of sorting -- min-heap for ascending, max-heap for descending, then just pop them all</li></ul>
