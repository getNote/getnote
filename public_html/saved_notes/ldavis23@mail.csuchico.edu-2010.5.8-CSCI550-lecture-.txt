    
    
    
<i>Lecture 1</i><br><br>Automata Theory<br>JFLAP<br><br><ul><li>Terminology<br></li><ul><li><b>Decidability</b> - can a solution be computed at all?</li><li><b>Tractability</b> - can a solution be computed using no more time than a polynomial (slowly growing) function of the size of the input?</li><ul><li><i>Tractable problems</i></li><ul><li>P - solvable in polynomial time</li><li>NP-complete - computes in non-polynomial time</li><ul><li>can a solution to the problem be quickly checked?<br></li></ul></ul><li><i>Intractable problems</i></li><ul><li>NP-hard -&nbsp;</li></ul></ul><li><b>The empty string - </b>denoted by epsilon Ïµ - it's a string, NOT A SET</li><ul><li>i.e. <br></li><ul><li>{ } = Ï´</li><li>Ïµ = ''<br></li></ul></ul></ul><li>Concepts</li><ul><li>Proofs</li><ul><li><b>Direct proof</b></li><ul><li>Show directly with mathematics that something is true<br></li></ul><li><b>Deductive proof</b></li><ul><li>Given a hypothesis H, provide a sequence of statements whose truth leads to a conclusion statement C; C is deduced from H</li><ul><li>Sample: 1+2+3+...+n (summation of i from 1 to n) = n(n+1)/2<br></li><ul><li>Write out 1+2+3+...+n-1+n</li><li>Write out n+n-1+...+3+2+1</li><li>Sum them</li><li>You get n sets of (n+1)</li><li>Since we summed it twice, divide it by two<br></li></ul></ul></ul><li><b>Mathematical induction</b></li><ul><li>Prove a statement S(x) about a family of objects X in three parts</li><ul><li>Basis - Show S(x) holds for one of several small values of X directly</li><li>Inductive Hypothesis - Assume S(Y) holds for values Y&lt;=<i>n</i></li><li>Inductive Step - show that S(<i>n</i>+1) holds using the inductive hypothesis</li><ul><li>Make sure your solution refers back to the inductive hypothesis</li></ul></ul><li>Sample - Prove summation of numbers 1 to n is n(n+1)/2 </li><ul><li>Basis: Show that â��i(1-&gt;n) = n(n+1)/2 = S(n)<br></li><ul><li>For n=1, 1(1+1)/2 = 1</li><li>Therefore, S(1) holds<br></li></ul><li>Inductive hypothesis: <br></li><ul><li>We will assume that S(n) holds for all values 1 &gt;= n &lt;= k<br></li></ul><li>Inductive step: <br></li><ul><li>Show that S(k+1) holds</li><li>Add S(k) to (k+1)</li><li>Transform to obtain S(k+1) by IH</li></ul></ul><li>Sample - Prove that a balanced binary tree with n leaves has 2n-1 nodes</li><ul><ul><li>Basis: If T is a one-node tree, then it has only one leaf; 1 = 2x1-1</li><li>Inductive Hypothesis: Assume S(u) holds for all binary trees U with at most k leaves.</li><ul><li>Hence if U is a binary tree with k leaves, then U has 2k-1 nodes</li></ul><li>Inductive Step: Consider a binary tree T with k+1 leaves</li><ul><li>T must have two sub-trees U and V</li><li>If U and V have u and v leaves, respectively, then T has u+v=k+1 leaves</li><li>By the inductive hypothesis, U and V have 2u-1 and 2v-1 nodes respectively</li><ul><li>Then T has 1+(2u-1)+(2v-1) nodes</li><ul><li>T has 2(u+v)-1 nodes</li><li>T has 2(k+1)-1 nodes, proving the inductive step<br></li></ul></ul></ul></ul></ul></ul><li><b>Proof by equivalence</b></li><ul><li>Prove by "if and only if"</li><ul><li>Two part proof<br></li><ul><li>Prove "if" part first</li><li>Provide "only if" part next</li></ul></ul></ul></ul><li>Languages</li><ul><li>Terminology</li><ul><li>Alphabet - finite set of symbols</li><ul><li>{0,1}</li><li>{a,b,c,...,z}<br></li></ul><li>String - finite sequence of symbols chosen from some alphabet</li><ul><li>011010<br></li></ul><li>Language - set of strings all from the same alphabet</li><ul><li>{0010,01010,1010011}</li></ul></ul><li>Operations</li><ul><li>Cartesian product A X B = { all ordered pairs (tuples) of A and B }</li><li>Dot product Aâ�¢B = { all strings -- cartesian without parens }<br></li><li>Expoentiated A^2 = Aâ�¢A = { all strings of length two }</li><li>E* = E^0 U E^1...</li><ul><li>Kleeny star, Infinite union of all strings over E -- any possible string you can make with E</li><li>Always contains epsilon, the empty string</li><li>Always results in a set</li><ul><li>{Ïµ}* = {Ïµ}</li><li>Ï´* = {Ïµ}</li></ul></ul><li>E+ = E^1 + E^2...</li><ul><li>Set of all non-empty strings over E -- any string you can make with E that is not empty<br></li></ul></ul><li>Structural representations<br></li><ul><li>Grammars</li><li>Regular Expressions</li></ul></ul></ul><li>Problems in automata theory</li><ul><li>A problem in automata theory is the question of deciding whether a given string is part of some particular language<br></li><li>Hence if â�� is an alphabet, and <i>L</i> is a language over â��, then the problem <i>L</i> is<br></li><ul><li>Given a string <i>w</i>â��â��*, we decide if wâ��<i>L</i></li></ul></ul></ul><br><br>-------<br><br><br><i>Lecture 2 - 2/2/10</i><br><br><br>In theory of computing, problems are modeled as <i>languages</i>, and programs are modled as <i>theoretical machines</i><br><br><br><ul><li><b>Finite automata</b></li><ul><li>an important way to describe certain simple, but highly useful languages called "regular languages"<br></li><li>anything that a finite automata can recognize is a "regular language"</li><li>Has nodes, called states</li><ul><li>All nodes are referred to as <i>Q</i><br></li></ul><li>Has arcs, labeled with symbols from some alphabet, represent changes that can be made<br></li><li>Changes states based on input</li><li>Start state is called <img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"></li><li>A transition function, takes a state and an input symbol, returns a state</li><li><i>F </i>is set of final states<br></li><li>FA represented by a 5 tuple</li><ul><li>A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)</li><ul><li>Q - Finite set of states</li><li>â�� - Finite set of input symbols</li><li>â�� - Transition function<br></li><li><img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"> - Start state</li><li><i>F</i> - Finite set of final or accepting states, subset of Q<br></li></ul></ul></ul></ul><br><ul><li>Deterministic finite automata</li><ul><li>DFA that recognizes strings in {0,1}* that end in 00</li><li>Will have |Q| * |â��| transitions <br></li><li>Sample 5 tuple given transition diagram from <font color="#ff0000">notes 2</font><br></li><ul><li>Q = {<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">, <img alt="q_{1}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B1%7D" style="vertical-align: middle;">, <img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">}</li><li>â�� = {0,1}</li><li>â�� = { (<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,0,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">), (<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,1,<img alt="q_{1}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B1%7D" style="vertical-align: middle;">), (<img alt="q_{1}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B1%7D" style="vertical-align: middle;">,0,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">), (<img alt="q_{1}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B1%7D" style="vertical-align: middle;">,1,<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">), (<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">,0,<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">), (<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">,1,<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">) }</li><li><img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"></li><li>{<img alt="q_{2}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%0A" style="vertical-align: middle;">}</li></ul></ul><li>Extended transition function - uppercase delta - â��</li><ul><li>Takes not just one symbol, but a whole string</li><li>Tells what state you end up after you process the string</li></ul><li>Defining a language<br></li><ul><li>L(A) = { w | â�� (<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,w) â�� F }</li><ul><li>That is, the language of A is the set of strings <i>w</i>â��â��* that take the start state <img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"> to one of the accepting states <br></li></ul></ul></ul><br><br>---<br><i><br>Lecture 3 - 2/3/2009</i><br><br>Empty set - â��<br><br>Empty string - Îµ<br><br><br><div id="w457" style="margin-left: 40px; text-align: left;"><b>DFA that accepts only </b>â��<br>â�� = {a,b}<br><div id="wil_" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_84hrgq25gw_b" style="height: 104px; width: 96px;"></div><br><br><b>DFA that accepts an even # of a's followed by at least 1 b, followed by zero or an odd # of a's<br></b>â�� = {a,b}<br><img src="https://docs.google.com/File?id=dhsgzc83_838jpvq64d_b" style="height: 221px; width: 459px;"></div><div style="margin-left: 40px;"><br><br><b>DFA for the following: L= { w â�� {0,1,2,3,4,5,6,7,8,9}* : decimal encoding w/o leading 0's of an odd natural #}</b><br>â�� = {0,1,2,3,4,5,6,7,8,9}<br></div><div id="n843" style="margin-left: 40px; text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_82f8wxgtg6_b" style="height: 246px; width: 435px;"></div><br><br>----<br><br><i>Lecture 4 - 2/8/10<br></i><br>Difference
 between DFA and NFA is in the transition function delta -- in DFA, we 
only have one state to go to, in NFA, we have multiple choices of which 
one to go to<br><br>Any problem solvable by a DFA can be solved by an 
NFA, and visa-versa -- they have equivalent power. We prove this with 
Subset Construction.<br><br>If a transition table is given with multiple states, it's an NFA<br><br><ul><li>A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)</li><ul><li>Q - {{0},{1},{2}}<br></li><li>â�� - {0,1}</li><li>â�� - Transition function<br></li><li>{0} - Start state</li><li><i>F</i> - Finite set of final or accepting states - {2}<br></li></ul></ul><br><table id="cbbo" width="500" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;"><b>â��</b></td><td style="text-align: center;"><b>0<br></b></td><td style="text-align: center;"><b>1<br></b></td></tr><tr><td style="text-align: left;">{0}</td><td style="text-align: center;">{0,1}</td><td style="text-align: center;">{0}</td></tr><tr><td style="text-align: left;">1</td><td style="text-align: center;"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"><br></td><td style="text-align: center;">{2}<br></td></tr><tr><td style="text-align: left;" valign="top">2</td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td></tr></tbody></table><br><br><b>To change NFA to DFA</b><br><ul><li>â�� stays the same<br></li><li>For a DFA equivalent an NFA, the start state <img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"> will become a set of states {<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">}</li><li><img alt="Q_{D} =2^{Q_{N}} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7BD%7D%20%3D2%5E%7BQ_%7BN%7D%7D%20" style="vertical-align: middle;"></li>&nbsp;<ul><li>The power set of the set of states for <img alt="Q_{N
}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7BN%0A%7D" style="vertical-align: middle;"></li><li>Inaccessible states can be thrown<br></li></ul><li><img alt="F_{D} =\{ { S }\in Q_{D} | S \cap F_{N} \ne \oslash \}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=F_%7BD%7D%20%3D%5C%7B%20%7B%20S%20%7D%5Cin%20Q_%7BD%7D%20%7C%20S%20%5Ccap%20F_%7BN%7D%20%5Cne%20%5Coslash%20%5C%7D" style="vertical-align: middle;"></li>&nbsp;<ul><li>The final states <img alt="F_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=F_%7BD%7D" style="vertical-align: middle;"> becomes a set of states from <img alt="Q_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7BD%7D" style="vertical-align: middle;"> containing a state in <img alt="F_{N}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=F_%7BN%7D" style="vertical-align: middle;"></li></ul><li>For<b> â�� </b>For <img alt="{ S }\in Q_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%7B%20S%20%7D%5Cin%20Q_%7BD%7D" style="vertical-align: middle;"> and <img alt="{ a }\in \Sigma " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%7B%20a%20%7D%5Cin%20%5CSigma%20" style="vertical-align: middle;"></li><ul><li><img alt="\delta_{D} (S,a) = \cup_{p\in x} \delta_{N}(p,a)" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cdelta_%7BD%7D%20%28S%2Ca%29%20%3D%20%5Ccup_%7Bp%5Cin%20x%7D%20%5Cdelta_%7BN%7D%28p%2Ca%29" style="vertical-align: middle;"></li>&nbsp;<ul><li>That means for â��({1,2}, 0) you take the union of â��({1}, 0) and â��({2}, 0) to obtain â��({1,2}, 0)</li></ul></ul><li><br><br><table id="ztd8" width="500" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;"><b>â��</b></td><td style="text-align: center;"><b>0<br></b></td><td style="text-align: center;"><b>1<br></b></td></tr><tr><td style="text-align: left;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td></tr><tr><td style="text-align: left;">-&gt; {0}<br></td><td style="text-align: center;">{0,1}</td><td style="text-align: center;">{0}</td></tr><tr><td style="text-align: left;">{1}<br></td><td style="text-align: center;"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"><br></td><td style="text-align: center;">{<img alt="q_{2} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B2%7D%20" style="vertical-align: middle;">}<br></td></tr><tr><td style="text-align: left;" valign="top">*{2}</td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td></tr><tr><td style="text-align: left;" valign="top">{0,1}</td><td style="text-align: center;" valign="top">{0,1}<br></td><td style="text-align: center;" valign="top">{0,2}<br></td></tr><tr><td style="text-align: left;" valign="top">*{0,2}<br></td><td style="text-align: center;" valign="top">{0,1}<br></td><td style="text-align: center;" valign="top">{0}<br></td></tr><tr><td style="text-align: left;" valign="top">*{1,2}<br></td><td style="text-align: center;" valign="top"><img alt="\oslash " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Coslash%20" style="vertical-align: middle;"></td><td style="text-align: center;" valign="top">{2}<br></td></tr><tr><td style="text-align: left;" valign="top">*{0,1,2}<br></td><td style="text-align: center;" valign="top">{0,1}<br></td><td style="text-align: center;" valign="top">{0,2}<br></td></tr></tbody></table></li></ul><br><br><b>Lazy way for figuring out delta:</b><br><br><ul><li>Instead of listing the set of all subsets, we just draw the start state</li><li>Then use the next reachable state as <img alt="S_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=S_%7BD%7D" style="vertical-align: middle;"> and write in the results<br></li></ul><br><table id="cck0" width="500" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;"><img alt="S_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=S_%7BD%7D" style="vertical-align: middle;"><br></td><td style="text-align: center;"><b>0<br></b></td><td style="text-align: center;"><b>1<br></b></td></tr><tr><td style="text-align: left;">-&gt; {0}</td><td style="text-align: center;">{0,1}</td><td style="text-align: center;">{0}</td></tr><tr><td style="text-align: left;">{0,1}<br></td><td style="text-align: center;">{0,1}<br></td><td style="text-align: center;">{0,2}<br></td></tr><tr><td style="text-align: left;" valign="top">*{0,2}<br></td><td style="text-align: center;" valign="top">{0,1}<br></td><td style="text-align: center;" valign="top">{0}<br></td></tr></tbody></table><br><br>NFA for strings of numbers such as 11 212 32123<br><div id="eabf" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_85cbfhfthq_b" style="height: 236px; width: 429px;"></div><br><br>Epsilon-NFA
 : A transition could be on epsilon -- on no input, we can go somewhere.
 In the example of decimal numbers, you may or may not have a + or - as 
the start symbol<br><br>----<br><br><i>Lecture 5 - 2/10/10</i><br><br><br>Epsilon transitions -- on no input, I can go from one state to another. Programming convenience.<br><br>In JFLAP, lambda <b>Î»</b> is empty string <br><br>In epsilon FAs, it's sometimes hard to see epsilon transitions in the middle of your string<br><br>An operation "closed" under that set, the operation has the same features as the original set???? research this<br><br><b>Epsilon Closure </b>for
 each state - returns a set of states that you can reach via an epsilon 
transition, or if no epsilon transitions out of initial state, then 
closure = initial state<br>ESPILON CLOSURE OF â�� is â��<br><br>Epsilon NFA has same 5 tuple<br><br><ul><li>A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)</li><ul><li>Q - Finite set of states</li><li>â�� - Finite set of input symbols</li><li>â�� - <img alt="QX\Sigma \cup  \{\varepsilon \} -&gt; Q" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=QX%5CSigma%20%5Ccup%20%20%5C%7B%5Cvarepsilon%20%5C%7D%20-%3E%20Q" style="vertical-align: middle;"><br></li><li><img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;"> - Start state</li><li><i>F</i> - Finite set of final or accepting states</li></ul></ul><br>Extended transition function takes a string, not just a symbol<br><br>If you insert epsilon into the transition function, the result is the epsilon closure of the state you are transitioning on<br>â��(q,Ïµ) = ECLOSE(q);<br><br>Epsilon NFA has the same power as a DFA<br><br><b>To change Epsilon NFA to DFA</b><br><ul><li>Start by drawing the transition table</li><ul><li>Include all symbols as columns</li><li>add ECLOSE column (which is not part of the table, used for reference)<br></li></ul><li>â�� stays the same<br></li><li>For a DFA equivalent an NFA, the start state&nbsp; <img alt="q_{d} = ECLOSE(q_{0})" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7Bd%7D%20%3D%20ECLOSE%28q_%7B0%7D%29" style="vertical-align: middle;"><br></li><li><img alt="Q_{D} =2^{Q_{E}} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7BD%7D%20%3D2%5E%7BQ_%7BE%7D%7D%20" style="vertical-align: middle;">&nbsp;</li><ul><li>The power set of the set of states for <img alt="Q_{N
}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7BN%0A%7D" style="vertical-align: middle;"></li><li>Inaccessible states can be thrown<br></li></ul><li><img alt="F_{D} =\{ { S }\in Q_{D} | S \cap F_{N} \ne \oslash \}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=F_%7BD%7D%20%3D%5C%7B%20%7B%20S%20%7D%5Cin%20Q_%7BD%7D%20%7C%20S%20%5Ccap%20F_%7BN%7D%20%5Cne%20%5Coslash%20%5C%7D" style="vertical-align: middle;">????</li>&nbsp;<ul><li>The final states <img alt="F_{D}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=F_%7BD%7D" style="vertical-align: middle;"> becomes a set of states????</li></ul><li>For<b> â�� </b>???????</li><ul><li>&nbsp;</li></ul></ul><br><br><ul><li>Start state of DFA is epsilon closure of start state of epsilon NFA</li><li>To get new set<br></li><ul><li>Union of the states AND<br></li><li>Union the epsilon closure for each of the states in the set<br></li></ul><li><br><table id="iff7" width="500" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;"><b>â��</b></td><td style="text-align: center;"><b>0-9<br></b></td><td style="text-align: center;"><b>epsilon<br></b></td><td valign="top"><b>+,-<br></b></td><td valign="top"><b>.<br></b></td><td valign="top"><b>ECLOSE<br></b></td></tr><tr><td style="text-align: left;" valign="top">&gt;0<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">{1}<br></td><td valign="top">{1}<br></td><td valign="top">â��</td><td valign="top">{0,1}<br></td></tr><tr><td style="text-align: left;">1<br></td><td style="text-align: center;">{1,4}<br></td><td style="text-align: center;">â��</td><td valign="top">â��</td><td valign="top">{2}<br></td><td valign="top">{1}<br></td></tr><tr><td style="text-align: left;">2<br></td><td style="text-align: center;">{3}<br></td><td style="text-align: center;">â��</td><td valign="top">â��</td><td valign="top">â��</td><td valign="top">{2}<br></td></tr><tr><td style="text-align: left;" valign="top">3<br></td><td style="text-align: center;" valign="top">{3}<br></td><td style="text-align: center;" valign="top">{5}<br></td><td valign="top">â��</td><td valign="top">â��</td><td valign="top">{3,5}<br></td></tr><tr><td style="text-align: left;" valign="top">4<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td><td valign="top">â��</td><td valign="top">{3}<br></td><td valign="top">{4}<br></td></tr><tr><td style="text-align: left;" valign="top">*5<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td><td valign="top">â��</td><td valign="top">â��</td><td valign="top">{5}<br></td></tr></tbody></table></li></ul><br><div style="margin-left: 40px;"><br></div><table id="pp7t" width="500" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;"><b>â��</b></td><td style="text-align: center;"><b>0-9<br></b></td><td style="text-align: center;" valign="top"><b>+,-<br></b></td><td style="text-align: center;" valign="top"><b>.<br></b></td></tr><tr><td style="text-align: left;" valign="top">{0,1}<br></td><td style="text-align: center;" valign="top">{1,4}<br></td><td style="text-align: center;" valign="top">{1}<br></td><td style="text-align: center;" valign="top">[2}<br></td></tr><tr><td style="text-align: left;">{1}<br></td><td style="text-align: center;">{1,4}<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">{2}<br></td></tr><tr><td style="text-align: left;">{2}<br></td><td style="text-align: center;">{3,5}<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td></tr><tr><td style="text-align: left;" valign="top">â�� </td><td style="text-align: center;" valign="top">â�� </td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td></tr><tr><td style="text-align: left;" valign="top">{1,4}<br></td><td style="text-align: center;" valign="top">{1,4}<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">{2,3,5}<br></td></tr><tr><td style="text-align: left;" valign="top">{3,5}<br></td><td style="text-align: center;" valign="top">{3,5}<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td></tr><tr><td style="text-align: left;" valign="top">{2,3,5}<br></td><td style="text-align: center;" valign="top">{3,5}<br></td><td style="text-align: center;" valign="top">â��</td><td style="text-align: center;" valign="top">â��</td></tr></tbody></table><br><br><br>Regular Expressions - algebraic descriptions of languages (as opposed to machine-like descriptions such as DFAs and NFAs)<br><br>For union, we'll use +<br><br>For concatenation, we'll directly concatenate them<br><br>Kleeny star - denotes the closure, results <br><br>Precidence<br><ul><li>Kleeny star: *</li><li>Concatonation: .</li><li>Union OR: +</li><li><img alt="B^{+} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=B%5E%7B%2B%7D%20" style="vertical-align: middle;"> - at least one<br></li></ul><br><br>{a,b}*&nbsp; = (a+b)*<br><br><br>----<br><br><br><i>2/17/10 Lecture</i><br><br><b>Annihilation</b> - anything your concactonate with â�� becomes â��<br><br>Distributive laws<br><br>Idempotent law for union<br><br>Exponentiation<br><br>Kleene star / Kleeny closure<br><br>Positive closure / plus closure<br><br><b>Laws involving closures</b><br><ul><li>(L*)* = L*</li><li>L? = Îµ + L</li></ul><br><b>Equivalencies</b><br><ul><li>(a+b)* = (a+b)* + (a+b)*</li><li>(a+b)* = (a+b)* + a*</li><li>(a+b)* = (a+b)*ab(a+b)* + b*a*</li></ul><br><b>Dynamic programming - memoization </b>- fancy term for using table lookup in recursive programming<br><br>Inorder <br>Preorder<br>Postorder<br><br><img alt="R_{i,j}^{k} = R_{i,j}^{k-1}  + R_{i,k}^{k-1} (R_{k,k}^{k-1})*R_{k,j}^{k-1} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=R_%7Bi%2Cj%7D%5E%7Bk%7D%20%3D%20R_%7Bi%2Cj%7D%5E%7Bk-1%7D%20%20%2B%20R_%7Bi%2Ck%7D%5E%7Bk-1%7D%20%28R_%7Bk%2Ck%7D%5E%7Bk-1%7D%29*R_%7Bk%2Cj%7D%5E%7Bk-1%7D%20" style="vertical-align: middle;"><br><br>In a non-parallel machine - Preorder traversal is the sequence in which the function calls ocurr<br><br>In fibbonachi done recursively, we will end up calculating f(2) and f(1) and f(0) if we're not caching what we've done<br><br><br><br><b>From DFAs to REs<br></b><ul><li>Let <img alt="Q_{a} = \{1,2,...,b\}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=Q_%7Ba%7D%20%3D%20%5C%7B1%2C2%2C...%2Cb%5C%7D" style="vertical-align: middle;"></li><li>Let <img alt="R_{ij}^{b} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=R_%7Bij%7D%5E%7Bb%7D%20" style="vertical-align: middle;"> denote an RE such that L(<img alt="R_{ij}^{b} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=R_%7Bij%7D%5E%7Bb%7D%20" style="vertical-align: middle;"> ) is the set of strings <i>w</i> such that <i>w</i> is the label of a path from state <i>i</i> to state <i>j</i> in <i>A</i>, and that the path has no intermediate node whose number is greater than <i>k</i> (Note: states <i>i</i> and <i>j</i> are not "intermediate" nodes)</li><li>Inductive definition</li><ul><li><b>BASIS: </b>(k=0) -- paths with no intermediate states, only looking at direct paths</li><ol><li>For i != j, no aâ��â�� such that DELTA(i,a) = j (null path or loop)</li><li>There exists aâ��â�� such that DELTA(i,a) = j (arc between i &amp; j)</li><ul><li>Find aâ��â�� such that</li></ul></ol></ul></ul><br>For N states you have N+1 iterations<br><br><b>Example<br></b><ul><li><b>DFA:</b></li><ul><li><div id="u_xb" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_109f4fcgdfx_b" style="height: 126px; width: 233px;"></div><br></li></ul><li><b>RE:</b> 1*0(0+1)*</li><ul><li><br></li><li><img alt="R^{[0]} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=R%5E%7B%5B0%5D%7D%20" style="vertical-align: middle;"> =<br></li><ul><li><table id="o6vk" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td width="50%">Îµ+1<br></td><td width="50%">0<br></td></tr><tr><td width="50%">â�� <br></td><td width="50%">(Îµ+0+1)<br></td></tr></tbody></table></li></ul><li>Test</li><li><br><br><br></li></ul></ul>---<br><i>2/22/10 Lecture<br></i><br><br>|Î´| = |Q| x |â��|<br><br>The number of transitions is equal to the number of states multiplied by the number of elements in the language<br><br><b><br>Dyn prog DFA to RE algorithm:</b><br><table id="w9q:" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td style="text-align: left;" width="33.333333333333336%"><b>Î´<br></b></td><td width="33.333333333333336%"><b>0<br></b></td><td width="33.333333333333336%"><b>1<br></b></td></tr><tr><td style="text-align: left;" width="33.333333333333336%"><b>&gt;1<br></b></td><td width="33.333333333333336%">2<br></td><td width="33.333333333333336%">1<br></td></tr><tr><td style="text-align: left;" width="33.333333333333336%"><b>2<br></b></td><td width="33.333333333333336%">3<br></td><td width="33.333333333333336%">1<br></td></tr><tr><td style="text-align: left;" width="33.333333333333336%"><b>*3<br></b></td><td width="33.333333333333336%">3<br></td><td width="33.333333333333336%">2<br></td></tr></tbody></table><br><div id="w_a4" style="text-align: left;"><div id="r:vu" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_111c6g34vgk_b" style="height: 109px; width: 319px;"></div><br></div><br>turns into:<br><br><table id="gz5w" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td width="25%"><br></td><td valign="top" width="25%"><b>1<br></b></td><td valign="top" width="25%"><b>2<br></b></td><td valign="top" width="25%"><b>3<br></b></td></tr><tr><td width="25%"><b>1<br></b></td><td width="25%">Îµ+1<br></td><td width="25%">0<br></td><td width="25%">â�� <br></td></tr><tr><td width="25%"><b>2<br></b></td><td width="25%">1<br></td><td width="25%">Îµ<br></td><td width="25%">0<br></td></tr><tr><td width="25%"><b>3<br></b></td><td width="25%">â�� <br></td><td width="25%">1<br></td><td width="25%">Îµ+0<br></td></tr></tbody></table><br><br><br><b>Converting DFAs to REs by eliminating States<br></b><br>For
 all q in F apply the reduction process to produce an eqiuivalent 
automaton with RE labels on the arcs. Eliminate all states except start 
and final.<br><br><br><br><br><br>---<br><i>Lecture 2/24/10</i><br><br><br><b>Exer 3.2.1 - p. 107<br></b><table id="z.5r" border="1" cellpadding="3" cellspacing="0"><tbody><tr><td width="33.333333333333336%"><b>Î´</b></td><td width="33.333333333333336%"><b>0</b></td><td width="33.333333333333336%"><b>1</b></td></tr><tr><td width="33.333333333333336%"><b>&gt;1</b></td><td width="33.333333333333336%">2</td><td width="33.333333333333336%">1</td></tr><tr><td width="33.333333333333336%"><b>2</b></td><td width="33.333333333333336%">3</td><td width="33.333333333333336%">1</td></tr><tr><td width="33.333333333333336%"><b>*3</b></td><td width="33.333333333333336%">3</td><td width="33.333333333333336%">2</td></tr></tbody></table><br><br><br><div id="zje5" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_119qvsnrxd6_b" style="height: 203px; width: 325px;"></div><div id="igt." style="text-align: left;"><br></div><div id="pgkw" style="text-align: left;"><b>Drop State 2:</b><div id="w-b5" style="text-align: left;">Think what would happen if State 2 was deleted...</div><div id="xtv6" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_120dwggzpdw_b" style="height: 110px; width: 273px;"></div></div><div id="x47p" style="text-align: left;"><br></div><div id="ixxv" style="text-align: left;"><br></div><div id="p.rw" style="text-align: left;">R = 1+01</div><div id="qk4g" style="text-align: left;">U = 0+10</div><div id="z:0g" style="text-align: left;">S = 00</div><div id="i73l" style="text-align: left;">T = 11</div><div id="fmas" style="text-align: left;"><br></div><div id="xotb" style="text-align: left;">RE = (R+SU*T)*(SU*) = (1+01)+(00)(0+10)*11)*00(0+10)*</div><br><b><br>Exer 3.2.2, p. 107</b><br><br><div id="iop8" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_121hh9zq2v7_b" style="height: 186px; width: 285px;"></div><div id="erp9" style="text-align: left;"><br></div><div id="bbxe" style="text-align: left;"><div id="dd56" style="text-align: left;"><b>Drop State 2:</b><div id="npwf" style="text-align: left;">Think what would happen if State 2 was deleted...</div><div id="b542" style="text-align: left;"><br></div></div><div id="v4ll" style="text-align: left;"><br></div><div id="e-eb" style="text-align: left;"><div id="ivls" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_1226qhqs8cs_b" style="height: 112px; width: 246px;"></div><br></div><div id="o4r-" style="text-align: left;">R = 00</div><div id="emss" style="text-align: left;">U = 01</div><div id="b4th" style="text-align: left;">S = 1+01</div><div id="yb3z" style="text-align: left;">T = 1+00</div><div id="ryge" style="text-align: left;"><br></div><div id="e78y" style="text-align: left;">RE = (R+SU*T)*(SU*) = (00+(1+01)(01)*(1+00))*(1+01)(01)*</div></div><br><br>---<br><br><div id="ckoa" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_124ch63b9f4_b" style="height: 204px; width: 261px;"></div><br>Add 4th state, epsilon transition from 1 and 2 to 4<br><br><div>Eliminate 3</div><br><div>Loop on 1 for ba</div><br><div id="b3t." style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_125hfddvvfs_b" style="height: 200px; width: 237px;"><div id="v5hv" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_126crdqfpdc_b" style="height: 112px; width: 241px;"></div><div id="j5eh" style="text-align: left;"><br></div><div id="e3us" style="text-align: left;">RE = (ba+(Îµ+aa*)â��*â�� )*(Îµ+aa*)(â��)*</div><div id="df:e" style="text-align: left;">...</div><div id="gd3p" style="text-align: left;">(Îµ+aa*) = a*</div><div id="py:a" style="text-align: left;">(Îµ+aa*)â��*â�� = ANAHILATED</div><div id="ilx8" style="text-align: left;">(â��)* = Îµ</div><div id="z5u1" style="text-align: left;">...</div><div id="g:gp" style="text-align: left;">&nbsp;&nbsp; &nbsp; = &nbsp;(ba)*a*</div><div id="s4_j" style="text-align: left;"><br></div><div id="m-st" style="text-align: left;"><br></div><div id="s8cn" style="text-align: left;">---</div><div id="afpc" style="text-align: left;"><br><br><b>Concretization</b><br>In order to prove that a property of a regular expression <b>does hold</b>, we use concretization.<br><br>Instantiate each thing in RE to set<br>Expand<br>End up with regular expression<br><br><b>Example:&nbsp; </b>(R*)* = R*<br>Let R = {a}<br>So (R*)* = ({a}*)*<br>= ({a}<sup>0</sup> U {a}<sup>1</sup> U {a}<sup>2</sup>.....})*<br>= ({Îµ,a,aa,a<sup>3</sup>,a<sup>4</sup>,...})*<br>={Îµ} U {Îµ,a,aa,a<sup>3</sup>,a<sup>4</sup>,...} U {Îµ,a,aa,a<sup>3</sup>,a<sup>4</sup>,...}...<br>&nbsp;= {a}* = R*<br><br><b><br>Example</b>: R(S+T) = RS+RT<br>Let &nbsp;&nbsp; &nbsp;R = {a}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; S = {b}<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;T = {c}<br><br>So R(S+t) = {a}({b}+{c})<br>= {a}({b}U{c})<br>= {a}{b,c}<br>= {ab,ac}*<br>={ab}U{ac}<br>={a}{b}U{a}{c}<br>= {a}{b}+{a}{c}<br>= RS + RT<br>---<br><br><br><b>CH 4<br></b><br>Moore/mealey machine have same power? huh?<br><br>Not all languages are regular<br><br><br><b>Pumping lemma for regular expressions<br></b><ul><li>Proof by contradiction</li><li>There exists a constant N such that for every string w in L such that w = xyz such that</li><ul><li>|w|&gt;=n<br></li><li>y != Îµ</li><li>|xy|&gt;= n</li><li>for all k&gt;=0, xy<sup>k</sup>z</li></ul><li>Assume it's regular</li><ul><li>Then L=L(a) for some DFA A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)</li><li>Suppose n = |Q|</li><li>Consider w in L where |w|&gt;= n</li><ul><li>Say w = a<sub>1</sub>a<sub>2</sub>...a<sub>m</sub>&nbsp; where m&gt;=m</li></ul><li><br></li></ul></ul><br>pumping: repeating<br><br><b>Properties:<br></b><ul><li>YOU CAN ONLY PUMP Y 0 or MORE TIMES (take away or add)<br></li><li>the string <i>w</i> must have a length &gt;=n</li><li>length of xy must be at most n</li><li>can't say anything about the length of y except that it's between 1 and n</li><li>z is always the rest of the string</li><li>xy<sup>i</sup>z&nbsp; where z &gt;= 0</li><li>Make sure you're clearly manipulating one symbol</li><li>if a language is finite, you can represent it with a finite state machine<br></li></ul><br><br>---<br><br><br>Proof that L<sub>1</sub> is not a regular language<br>L<sub>1</sub> = <img alt="L_{1} = \{ w \in {0,1}*\ | w = 0^{n} 1^{n} , \geq  1}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=L_%7B1%7D%20%3D%20%5C%7B%20w%20%5Cin%20%7B0%2C1%7D*%5C%20%7C%20w%20%3D%200%5E%7Bn%7D%201%5E%7Bn%7D%20%2C%20%5Cgeq%20%201%7D" style="vertical-align: middle;"><br><br><ol><li>Assume L<sub>1 </sub>is regular<br>A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)<br>Where L(A) = L<sub>1</sub> and |Q| = n</li><li>Consider <img alt="w \in L" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=w%20%5Cin%20L" style="vertical-align: middle;"> where |w| =&gt; n<br>w = 0<sup>n</sup>1<sup>n<br></sup>|w| = 2n &gt; n<br></li><li>w = xyz <br>where y != Îµ, |xy| &lt; = n<br>1 &lt;= |y| &lt;= n</li><li>w = 000...0111...1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----n--|---n---&nbsp;&nbsp;&nbsp; &lt;-- lengths of n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp; x, y ][&nbsp;&nbsp; z&nbsp; ]</li><li>When you pump the Y, xyyz is NOT in L =&gt; unequal number of 0's and 1's<br></li></ol><br><br>L<sub>2</sub> = set of strings of balanced parenthesis<br><ol><li>Assume L<sub>1 </sub>is regular<br>A = (Q,â��,â��,<img alt="q_{0} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=q_%7B0%7D%20" style="vertical-align: middle;">,<i>F</i>)<br>Where L(A) = L<sub>1</sub> and |Q| = n</li><li>Consider <img alt="w \in L" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=w%20%5Cin%20L" style="vertical-align: middle;"> where |w| =&gt; n<br>w = (<sup>n</sup>)<sup>n</sup><br>|w| = 2n &gt;= n<br></li><li>w = xyz <br>where y != Îµ, |xy| &lt; = n<br>1 &lt;= |y| &lt;= n</li><li>w = (((.....())).....)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----n--|---n---&nbsp;&nbsp;&nbsp; &lt;-- lengths of n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [&nbsp; x, y ][&nbsp;&nbsp; z&nbsp; ]</li><li>When you pump the Y, xyyz is NOT in L =&gt; unequal number of ('s and )'s<br></li></ol><br>----<br><br><br><b>Closures of regular expressions<br></b><br><div style="text-align: left;"><ul><li>If <i>L</i> and <i>M</i> are RLs, then so is <img alt="L \cup M" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=L%20%5Ccup%20M" style="vertical-align: middle;"></li><ul><li>The alphabet does not have to be the same</li><li>The set of states is Q<sub>1</sub> U Q<sub>2</sub> U s</li><ul><li>s is a new start state</li></ul><li>The language is the union of both Epsilon<br></li><li>Final states is union of both F<br></li></ul><li>If <i>L</i> and <i>M</i> are RLs, then so is <img alt="L M" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=L%20M" style="vertical-align: middle;"></li><ul><li>The set of states is Q<sub>1</sub> U Q<sub>2</sub></li><li>The language is the union of both</li><li>Final states is just F<sub>2</sub></li><li>The
 transition function is the union of both, and for every final state in 
the first, epsilon transition to the start state of the second</li></ul><li>Closure under Keene star<br></li><ul><li>If <i>L</i> is regular, then so is <i>L</i>*</li></ul><li>Closure under complentation</li><ul><li>If <i>L</i> is regular over â��, then so is&nbsp;<img alt="\bar{L}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cbar%7BL%7D" style="vertical-align: middle;">= â��*-<i>L</i></li></ul><li>Closure under intersection<br></li><ul><li>If <i>L</i> and <i>M</i> are regular, then so is <img alt="L \cap M" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=L%20%5Ccap%20M" style="vertical-align: middle;"></li></ul><li>Closure under difference<br></li><ul><li>If <i>L</i> and <i>M</i> are regular, then so is <i>L</i>-<i>M</i><br></li></ul></ul></div><br>----<br></div><div id="y7:1" style="text-align: left;"><br></div></div><div id="f9pq" style="text-align: left;"><br><b>Test study notes<br></b><br></div><div id="ka4d" style="text-align: left;"><ul><li>To prove if a language is regular, you need to show a regular expression or finite state machine.</li><ul><li>Any
 time you're keeping track of two related counts at once for two 
different characters, it's not regular because you need an infinite 
number of states</li><li>Any time you're keeping track of squares, an FSM cannot solve it -- prove this using pumping lemma</li><li>Anything that requires a stack (i.e. if you're reversing), you cannot solve with a FSM</li></ul><li>Anything that's modulo for count you can solve with a circle of states<br></li><li>Language - just a set of strings</li><li>Kleeny star of empty set is epsilon (â��)* = Îµ</li><li>To prove two REs are not equivalent, just show a string that's not in one but is in the other</li><li>REGULAR LANGUAGES ARE CLOSED UNDER REVERSAL</li><ul><li>if
 you can figure out the reverse, switch the arrow and make start state 
final state, and final states have one state while epsilon transitions 
to them</li></ul><li>Regular languages are closed under intersection (AND)<br></li><ul><li>So you can show both parts of a language with an AND in it and claim the language is regular</li><li>To show this, you'd take the cross product of the states in both machines effectively making them run at the same time</li></ul><li>Regular languages are closed under union (OR)</li><li>Regular languages are NOT closed under infinite union (OR)<br></li><li>Pumping lemma tips</li><ul><li>if you can isolate y to be a single symbol, it's easiest</li><li>if you cannot, look at the case it would be odd or ever, prove that both fails<br></li></ul><li>Keeping track of a factorial length is non regular</li></ul></div><br><b><br>STUFF TO STUDY<br></b><ul><li><font><span style="background-color: rgb(255, 255, 0);">â��</span></font>Proof my mathematical induction</li><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>Alphabets, languages, strings<br></li><li><font><span style="background-color: rgb(255, 153, 0);">â��</span></font>Set theory</li><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>Designing FAs</li><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>NFA -&gt; DFA</li><ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font> lazy method</li><ul><li><i>Start with first line as is</i></li><li><i>Add new state for each unique pair</i></li><ul><li><i>For each symbol, union result for each of the states in the unique pair for that symbol</i></li></ul><li><i>Expand all new unique pairs</i></li><li><i>* next to all pairs containing a final state<br></i></li></ul></ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font> Îµ-NFA -&gt; DFA</li><ul><li><i>First make table with Îµ-close</i></li><li><i>Begin other table with Îµ-close of start state</i></li><li><i>Expand</i></li><ul><li><i>Add the union of the Îµ-close of the states referenced by the LHS for each input symbol</i><br></li></ul></ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>Regular expressions</li><ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>Annihilation</li><ul><li><i>Only happens on concatenation with empty set</i><br></li></ul></ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>RE -&gt; Îµ-NFA</li><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>FA -&gt; RE?</li><ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font> state elimination<br>RE = (R+SU*T)*(SU*)</li><ul><li><i>Eliminate states that are not start and final</i></li><li><i>RSU/T</i></li><li><i>Write RE using forumla</i><br></li></ul><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>big ass algorithm<br><img alt="R_{i,j}^{k} = R_{i,j}^{k-1}  + R_{i,k}^{k-1} (R_{k,k}^{k-1})*R_{k,j}^{k-1} " class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=R_%7Bi%2Cj%7D%5E%7Bk%7D%20%3D%20R_%7Bi%2Cj%7D%5E%7Bk-1%7D%20%20%2B%20R_%7Bi%2Ck%7D%5E%7Bk-1%7D%20%28R_%7Bk%2Ck%7D%5E%7Bk-1%7D%29*R_%7Bk%2Cj%7D%5E%7Bk-1%7D%20" style="vertical-align: middle;"></li><ul><li><i>Start with table with states as X and Y</i></li><li><i>Include Îµ for 1-1, 2-2, 3-3, etc</i></li><li><i>Use formula to generate list</i></li><ul><li><i>Middle two stay the same for each i</i></li></ul><li><i>Minimize REs</i></li><li><i>Build next table using list from previous iteration</i></li><li><i>Final RE is start state to final state for last iteration</i><br></li></ul></ul><li><font><span style="background-color: rgb(255, 255, 0);">â��</span></font>Concretization - proving equivalence of regular expressions<br></li><li><font><span style="background-color: rgb(0, 255, 0);">â��</span></font>Pumping Lemma<br></li></ul><br><br>---<br><b>IS IT REGULAR: Class time fun review</b><br><br>a. Given&nbsp; â�� = {[000],[001],[010],...[111]}<br><ul><li>Each symbol is a triple |â��| = 8</li><li>You'd represent this using 0-7, instead of the triple [001], you'd have 1<br></li></ul><br>L<sub>a</sub> = { w IN â��* : w represents valid binary additions}<br><br>example:<br><br>&nbsp; 0110<br>+0101<br>-------<br>&nbsp; 1011<br><br><div id="y8k7" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_150hnb2v6dw_b" style="height: 156px; width: 246px;"><br><br>---<br><br>b. L<sub>4</sub> = {w IN {Y,N}*: w has at least 2 Y's and at most 2 N's}<br><br>Prove L and M separately, then say "L<sub>4</sub> is regular as L and M are regular and regular languages are closed under intersection"<br></div><br>----<br><br>L<sub>B</sub> = { a<sup>n</sup>b<sup>m</sup> : n =&gt; 1, m &gt; = 0} U {BA}<br><br>&nbsp;&nbsp;&nbsp; It is regular, a<sup>+</sup>b<sup>*</sup>+ba<br><br>L<sub>C</sub> = { a<sup>n</sup>b<sup>m</sup> n &gt;= 1} U { a<sup>n</sup>b<sup>m</sup> : n &gt;= 1, m &gt;= 1}<br><br>&nbsp;&nbsp; List out the first few strings, picture the union -- it's really just a<sup>n</sup>b<sup>m</sup> and it is regular<br><br>L<sub>D</sub> = { (ab)<sup>n</sup>a<sup>k</sup> : n &gt; k, k &gt;= 0 }<br><br>&nbsp;&nbsp;&nbsp; w = (ab)<sup>n</sup>a<sup>n-1</sup><br>&nbsp;&nbsp;&nbsp; In a proof by pumping lemma when you have a case where |y| is either odd or even, show both for a better proof.<br><br><br>----<br><br>â�� = {a,b}<br><br>L<sub>E</sub> = { uv : u â�� L, |v| = z }<br><br>&nbsp;&nbsp; &nbsp;<br><br>L<sub>F</sub> = { a<sup>n</sup>b<sup>k</sup>c<sup>n+k</sup> : n&gt;=0, k&gt;=0 }<br><br>&nbsp;&nbsp;&nbsp; w = a<sup>n</sup>c<sup>n</sup><br><br>L<sub>G</sub> = { a<sup>n</sup> : n=k<sup>3</sup> for k &gt;= 0}<br><br>&nbsp;&nbsp;&nbsp; w = a<sup>n^3</sup><br>&nbsp;&nbsp;&nbsp; x,z = Îµ<br><br> L<sub>H</sub> = { uww<sup>R</sup>y : u,w,y â�� {a,b}<sup>+ </sup>}<br><br>&nbsp;&nbsp;&nbsp; (a+b)<sup>+</sup>(aa+bb)(a+b)<sup>+</sup><br><br><br> L<sub>I</sub> = { xyzy<sup>R</sup>x : x,y,z â�� {a,b}<sup>* </sup>}<br><br>&nbsp;&nbsp;&nbsp; (a+b)*<br><br><br> L<sub>J</sub> = { w â�� {a,b}<sup>* </sup>: number of occurrences of "ab" equals number of occurrences of "ba" }<br><br><div style="text-align: left;">&nbsp;&nbsp;&nbsp; a<sup>*</sup>+ b<sup>*</sup> + a<sup>+</sup>b<sup>+</sup>a<sup>+</sup>(b<sup>+</sup>a<sup>+</sup>)<sup>*</sup> + b<sup>+</sup>a<sup>+</sup>b<sup>+</sup>(a<sup>+</sup>b<sup>+</sup>)<sup>*</sup><br><br></div><br><br><div>----</div><br><br><div>DFA minimization</div><br><br><ol><li>List all states as root of tree</li><li>Left side are final states</li><li>Right side are all non-final states</li><li>Split states in leaves by which ones go to a final state and which ones do not</li></ol><br><br><br><div><img src="http://docs.google.com/drawings/image?w=400&amp;h=400&amp;ac=1&amp;id=skCgo_a_9sz4wweTnHSrIQA&amp;rev=41"></div><br><div>To draw new DFA:</div><ul><li><br></li></ul><div id="lxj2" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_157hjccf4fn_b" style="height: 221px; width: 352px;"></div><div id="tc2_" style="text-align: left;"><br></div><div id="hd6w" style="text-align: left;">---</div><div id="j1:9" style="text-align: left;"><br></div><div id="stth" style="text-align: left;"><br></div><div id="fwd." style="text-align: left;">Set notation review</div><div id="iiv9" style="text-align: left;"><br></div><div id="ytw2" style="text-align: left;">A = { 1,2,3 }</div><div id="gygz" style="text-align: left;">B = { a,b,c }</div><div id="qs29" style="text-align: left;"><br></div><div id="t45k" style="text-align: left;">A U B = { 1,2,3,a,b,c }</div><div id="wgkx" style="text-align: left;"><br></div><div id="tg06" style="text-align: left;"><div id="iopk" style="text-align: left;">A U B != {a}U{b}</div><br></div><div id="u3ny" style="text-align: left;">--</div><div id="f-z7" style="text-align: left;"><br></div><div id="nfni" style="text-align: left;"><br></div><div id="b8jv" style="text-align: left;">Is it possible to find a regular language Lr and non-regular language Ln such that Lr=Ln = NO</div>Is it possible to find a regular language Lr and non-regular language Ln such that Lr IS IN Ln = YES<br><div>Is it possible to find a regular language Lr and non-regular language Ln such that Ln IS IN Lr = YES</div><br><br><br><div><img src="http://docs.google.com/drawings/image?w=400&amp;h=400&amp;ac=1&amp;id=s4l9oXlHwFNguB5-g4CFhnA&amp;rev=25"><br></div><br><br><div><b>Context free grammars</b></div><br><div>Proof that a language is context free:</div><ul><li>Come up with a context free grammar</li><ul><li>described by a 4 tuple - G = (V,T,P,S)</li><ul><li>V - set of variables - UPPER CASE LETTERS</li><ul><li>start variable</li><li>alphabet symbols</li></ul><li>T - set of terminals - lowercase alphabetic, numeric, epsilon</li><li>P - set of pairs</li><ul><li>variable on the left</li><li>body on the right</li><ul><li>var on left can be replace by any symbol on the right side of the body</li></ul></ul><li>S - start symbol (when you have more than 1 production)</li></ul><li>P-&gt;Îµ</li><li>P-&gt;0</li><li>P-&gt;!</li><li>P-&gt;0P0</li><li>P-&gt;1P1</li></ul></ul><br><div>---</div><br><div>G = ({S,A},{0,1},P,S)</div><div><i>CFG that generates strings of 0's and 1's such that each block of 0's is followed by at least as many 1's where P is denoted by:</i></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;">S-&gt; AS|Îµ<br>A-&gt;0A1|A1|01</blockquote><br><br><div><b>Recursive inference</b> - starts from the body of string and goes to the head (start symbol)</div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><font face="'Courier New'">Start with:<br></font><font size="3"><font face="'Courier New'">0 1 1 0 1</font></font><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font size="3"><font face="'Courier New'">[A]</font></font></blockquote><br><div><b>Derivations</b> - uses productions to build string</div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;">S=&gt;AS=&gt;A1S=&gt;011S=&gt;011AS=&gt;01101S=&gt;01101Îµ</blockquote><br><div>Sentential form - any string with variables and terminals</div><br><div>Leftmost derivation: Always replaces the leftmost&nbsp;<i>variable</i>&nbsp;in a sentential form</div>Rightmost derivation: Always replaces the rightmost&nbsp;<i>variable</i>&nbsp;in a sentential form<br><br><div>In order to prove a string can be generated by a CFG, use derivation and recursive inference or a parse tree.</div><br><br><div><b>Parse trees</b></div><img src="http://docs.google.com/drawings/image?w=400&amp;h=400&amp;ac=1&amp;id=syeGF97qZ0cJD0Hsjbcl5FQ&amp;rev=40"><br><br><div id="wngm" style="text-align: left;"><img src="https://docs.google.com/File?id=dhsgzc83_158f4v7dhg6_b" style="height: 480px; width: 640px;"></div><div id="o1sg" style="text-align: left;"><br></div><div id="eukh" style="text-align: left;"><b>Ambiguous</b>
 - A grammar is ambiguous if, given a string, I can come up with two 
different trees that yield the same string. Cannot use ambiguous 
grammars for programming languages. Precedence can remove ambiguity.</div><br>Operators that have the same precedence must be evaluated from left to right<br><br><div><b>Inherent ambiguity</b> - a CFL is inherently ambiguous if <b>all</b> its grammars are ambiguous.&nbsp;</div><br><br><div><img alt="L = \{ a^{n}b^{n}c^{m}d^{m} | n \geq 1, m \geq 1 \} \cup \{ a^{n}b^{m}c^{m}d^{n} | n \geq 1, m \geq 1 \}" class="ee_img tr_noresize" src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=L%20%3D%20%5C%7B%20a%5E%7Bn%7Db%5E%7Bn%7Dc%5E%7Bm%7Dd%5E%7Bm%7D%20%7C%20n%20%5Cgeq%201%2C%20m%20%5Cgeq%201%20%5C%7D%20%5Ccup%20%5C%7B%20a%5E%7Bn%7Db%5E%7Bm%7Dc%5E%7Bm%7Dd%5E%7Bn%7D%20%7C%20n%20%5Cgeq%201%2C%20m%20%5Cgeq%201%20%5C%7D" style="vertical-align: middle;"><br></div><br><div><b>Left side part:</b></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;">S-&gt;XY<br>X-&gt;aXb|ab<br>Y-&gt;cYd|cd</blockquote><br><div><b>Right side part:</b></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;">S-&gt;aSd|aAd<br>A-&gt;bAc|bc</blockquote><br><br><div>L = { a<sup>n</sup>b<sup>m</sup>c<sup>n+m</sup>&nbsp;: n,m &gt;= 0 }</div><br><div>A-&gt;aAc|B</div><div>B-&gt;bBc|Îµ</div><br><br><div>L = { w IN {a,b}* : #<sub>a</sub>(w) = #<font size="2">b</font>(w) }</div><br>S-&gt; AS|Îµ<br>A-&gt; aAb|bAa|Îµ<br><br><div>---<br><br><div><i>For any regular language, you can write a context free grammar:</i></div><div>&nbsp;&nbsp; &nbsp;<b>example:</b>&nbsp;a*<br></div><ul><li>CFG:</li><ul><li>P-&gt;Îµ | aP</li></ul></ul><br><div>&nbsp;&nbsp; &nbsp;<b>example:</b>&nbsp;a* + b*<br></div><ul><li>CFG:</li><ul><li>S-&gt;A | B</li><li>A-&gt;aA | Îµ</li><li>B-&gt;bB | Îµ</li></ul></ul><br><div>&nbsp;&nbsp; &nbsp;<b>example:</b>&nbsp;(a + b)*<br></div><ul><li>CFG:</li><ul><li>S-&gt; aS | bS | Îµ</li></ul></ul><br><br><div><b>Notes:</b></div><ul><li>Keeping track of counts can be done with a middle replacement i.e. A-&gt;0A1</li></ul><br><br>-----</div><b><br></b><div><b>Practice</b></div><br>L = { w IN {a,b}* : |w| is odd }<br><div>S-&gt;aSb|bSa|aSa|bSb|a|b</div><br><br>-------<br><br><img src="https://docs.google.com/File?id=dhsgzc83_179dvjbpbfn_b" style="height: 480px; width: 640px;"><br><br><div>G = VTPS</div><div>V = variable</div><div>t = terminal</div><div>p = production</div><div>S = start</div><br><br>From CFG to PDA - have little baby whale blowing crap<br><br><div><b>CFG:</b><br>G(VTPS) =&gt; A =({q}, E, VUE, bullshit, q, S, EMPTY)</div><br><br>One state PDA that accepts by empty stack<br>Simulates leftmost derrivation<div>NUmber of transition is equivalent to the nubmer of productions plus the number of TERMINAL alphabet symbols<br><br><div>When B-&gt;a, add transition SIGNMA(q,a,a) = {(q,Îµ)}</div><br>Convert to PDA:<br><div>L = { a<font size="2"><sup>n</sup>b<sup>2n</sup>&nbsp;: n &gt;= 1}</font></div><br><div>1. Given CFG:</div><br><div>S-&gt;A|abb</div><div>A-&gt;aAbb<br></div><br>2. Rules:</div><br><div>b,b;Îµ</div><div>a,b;Îµ</div><div>Îµ,S;abb</div><div>Îµ,S;aSbb</div><br>---<br><br><div>When the CFG-to-PDA executed:</div><br><div>L(G) = N(A)</div><br><div>L when accepting by final state</div><div>N when accepting by empty state</div><br>---<div><b>OR JUST READ THIS WONDERFUL LITTLE SNIPPET THAT JOSH TOLD ME:</b></div><div>For every terminal, read and pop<div>For every production, read nothing, variable on stack, push production result</div><br><br><br>------<br><br><div><b>PDA =&gt; CFG</b></div><br>A = (Q, SIGMA, GAMMA, DELTA, q0, z0, F) =&gt;<div>G = (V, T, P, S)</div><br><div>T = SIGMA</div>V = Start symbol S, then all symbols of the form [qXp] where q,p ARE IN states and X IS IN GAMMA --- that's a composite symbol<br><br><div><i>Number of variables in our CFG</i></div><div>|V| = |Q|<sup>2</sup>x|GAMMA| + 1</div><br>P =&nbsp;<br><br><div>The good stuff: http://www.ecst.csuchico.edu/~juliano/csci550/Slides/pda2cfg/img3.html<br><br><br><br><b>PDA-&gt;CFG example:</b></div><br><div>Baby whale with the following: (every sequence of 0's is followed by at least as many 1's)</div><br><div>0,0,Îµ&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(1)</div><div>1,1;Îµ&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(1)</div><div>Îµ,Z;SZ&nbsp;&nbsp; &nbsp;(2)</div><div>Îµ,S;AS&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;(2)</div><div>Îµ,S;Îµ&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(1)</div><div>Îµ,A;0A1&nbsp;&nbsp; &nbsp;(3)</div><div>Îµ,A;A1&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(2)</div><div>Îµ,A;01&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(2)</div><br><div>A = ({q},{0,1},{Z}U{S,A,0,1},DELTA,q,Z0, EMPTY)</div><br><br>T = SIGMA<br>V = {S,[qZq],[qSq],[qAq],[q0q],[q1q]}<div>P = (1) uses popping rule</div>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(q,Îµ) IS IN LSIGMA(q,0,0)&nbsp;&nbsp; &nbsp;:&nbsp;&nbsp; &nbsp;[q0q]-&gt;0<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,Îµ) IS IN LSIGMA(q,1,1)&nbsp;&nbsp; &nbsp;:&nbsp;&nbsp; &nbsp;[q1q]-&gt;1 &nbsp; &nbsp; &nbsp; &nbsp;<div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,Îµ) IS IN LSIGMA(q,Îµ,S)&nbsp;&nbsp; &nbsp;:&nbsp;&nbsp; &nbsp;[qSq]-&gt;Îµ</div><div>&nbsp;&nbsp; &nbsp;(2) one stack symbol replaced by 2</div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,SZ) IS IN LSIGMA(q,Îµ,Z)&nbsp;&nbsp; &nbsp;: &nbsp; &nbsp;[qZq] -&gt; Îµ[qSq][qZq]<div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,AS) IS IN LSIGMA(q,Îµ,S)&nbsp;&nbsp; &nbsp;: &nbsp; &nbsp;[qSq] -&gt; Îµ[qAq][qSq]&nbsp;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,A1) IS IN LSIGMA(q,Îµ,A)&nbsp;&nbsp; &nbsp;: &nbsp; &nbsp;[qAq] -&gt; Îµ[qAq][q1q] &nbsp; &nbsp;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,01) IS IN LSIGMA(q,Îµ,A)&nbsp;&nbsp; &nbsp;: &nbsp; &nbsp;[qAq] -&gt; Îµ[q0q][q1q] &nbsp; &nbsp;&nbsp;</div><div>&nbsp;&nbsp; &nbsp;(2) one stack symbol replaced by 3</div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;(q,0A1) IS IN LSIGMA(q,Îµ,A)&nbsp;&nbsp; &nbsp;: &nbsp; &nbsp;[qAq] -&gt; Îµ[q0q][qAq][q1q] &nbsp;&nbsp;&nbsp;<br><br><br><div id="nobr" style="text-align: left;"><br></div><div id="ep-3" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;">----</div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><b>DPDA</b> - same as normal pda but no non-determinism and no epsilons</div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;">PDA != DPDA</div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;">--</div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><b>Normalization</b></div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;">CNF - chomsky normal form</div><div id="fo-q" style="text-align: left;"><br></div><div id="fo-q" style="text-align: left;"><br></div><b>All productions in Chomsky normal form are like this:</b></div><div>A-&gt;BC&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Variable replaces by two variables</div><div>A-&gt;a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Variable replaced by a single terminal</div><br><div><b>Fun stuff:</b> The parse tree is a binary tree for these CFGs<br><br><br>Preprocessing tasks:</div><ol><li>Eliminate useless symbols x IS IN V U E that do not appear in any derivation of a terminal string from S</li><li>Eliminate epsilon productions A-&gt;Îµ</li><li>Eliminate unit productions A-&gt;B</li></ol><br><div>Generating symbols - if X=&gt;w for w IS IN E</div><br><div>Reachable symbols - there is a derivation S=&gt;aXB</div><br><div>ORDER OF STEPS:</div><ul><li>Eliminate epsilon productions</li><li>Eliminate unit productions</li><li>Eliminate useless symbols</li></ul><br><div><b>STEPS:</b></div><div>Phase1: Bottom up - Eliminate all non generating symbols</div><ul><li>Assume all terminals are generating.</li><li>If all the elements in the RHS of a production contain generating symbols, then the variable on the left is also generating</li></ul><br><div>Phase2: Top down - Eliminate all unreachable symbols</div><ul><li>S is reachable.</li><li>If the variable on the left side is reachable, then the stuff on the right is reachable</li></ul><br><div>Phase 3: Eliminate all epsilon productions</div><ul><li>Identify a set of variables known as nullable - only those symbols that can eventually derive epsilon in 0 or more steps<br></li><li>Any variable that can end up with epsilon is nullable</li></ul><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>Round 1: Identify all the nullable symbols on the grammar</div><div>Round
 2: If a variable X is nullable, then we can replace productions that 
have it on the RHS, we can create two version of the production -- one 
with X, one without it</div></blockquote><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>if all variables in a given production are nullable, don't include that case</div></blockquote></blockquote>Phase 4: Eliminate unit productions<br><ul><li>Identify all unit pairs</li><li>Unit pair: Pair (A,B) where A=&gt;B</li><li>If (A,B) is a unit pair, and we have B=&gt;C, then (A,C) is also a unit pair</li></ul><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>Round 1: Find all the unit pairs of G</div><div>Round 2: For each unit pair (A,B) where you have B-&gt;a, add production A-&gt;a</div></blockquote><br><div><b>Ex:</b></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><br><div>G = (VTPS)</div><div>S-&gt;AB|C</div><div>B-&gt;1|A0</div><div>A-&gt;0B|C</div><div>C-&gt;AC|C1</div><br><b>Phase 1:</b><div>All terminals are generating</div>Look at productions where RHS is only terminals -- the LHS is also a generating symbol (see B-&gt;)<div>Look at productions where RHS is only generating symbols, repeat</div><br><div>GEN = {0,1,B,A,S}</div><br><div>Nothing more can be added, and C is not a generating symbol, so we can get rid of everything with a C</div><br><div><b>Phase 2:</b></div><div>Start with S.</div><div>Look at productions where the LHS is reachable, all on the right are reachable</div><br><div>REACH = {S,A,B,0,1}</div><br><div>Since it's the same set as GEN, then there are no more useless symbols.</div><br><b>Phase 3:</b><div>Eliminating epsilon productions</div><br>Identify a set of variables known as nullable - only those symbols that can eventually derive epsilon in 0 or more steps<br><br><b>Phase 4:</b> Chompsky normal form<br><br>For productions with bodies of length 2 or more with variables that point to the terminals in them<br>i.e. take out the terminals and replace them with a variable that goes only to that terminal<br><br>For each production with 3 variables, replace the two rightmost variables with another variable that goes to those two.<br><br><br></blockquote><b>Ex:</b><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>S-&gt;AB</div><div>A-&gt;aAA|Îµ</div><div>B-&gt;bBB|Îµ</div></blockquote><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;">Identify nullables:<br>A and B can go to Îµ, and S can go to AB, so S is also nullable.<br><br>NULLABLE = {A,B,S}<br><br>S-&gt;AB &nbsp; &nbsp; &nbsp; GOES TO &nbsp; &nbsp; S-&gt;AB|A|B<br>A-&gt;aAA&nbsp;&nbsp; &nbsp;&nbsp;GOES TO&nbsp;&nbsp;&nbsp; &nbsp;A-&gt;aAA|aA|a<br>B-&gt;bBB&nbsp;&nbsp; &nbsp;GOES TO&nbsp;&nbsp;&nbsp; &nbsp;B-&gt;bBB|bB|b</blockquote><br><br><div>----</div><br><div>Example 7.1.1 p 275</div><br><div>Given CFG, G = (V,T,P,S) where&nbsp;</div><div>P:&nbsp;</div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>S-&gt;AB|CA</div><div>A-&gt;a</div><div>B-&gt;BC|AB</div><div>C-&gt;aB|b&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &lt;- not in CNF because variable must be replaced by two variables or a terminal</div><br></blockquote>Eliminate useless symbols<br><br>1: GENERATING = {a,b,A,C,S}<div>Eliminate everything that's not in generating:</div><br><div>S-&gt;CA</div><div>A-&gt;a</div><div>C-&gt;b</div><br><div>2: REACHABLE = {S,C,A,a,b}</div><br><div>No non-reachable symbols, we've effectively eliminated useless symbols</div><br><br><div>----</div><br><div>Example 7.1.2 p 275</div><br><div>Given CFG:</div><br><div>P:&nbsp;</div><div>S-&gt;ASB|Îµ</div><div>A-&gt;aAS|a</div><div>B-&gt;SbS|A|bb</div><div><br>1: Eliminate epsilon productions</div>Identify all nullable symbols (any var that can be replaced by epsilon)<blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>NULLABLE = {S}</div><br><div>As a result, eliminate S-&gt;Îµ:</div><br><div>p1:</div><br><div>S-&gt;ASB|AB</div><div>A-&gt;aAS|aA|a</div><div>B-&gt;SbS|bS|Sb|b|A|bb</div></blockquote><br>2: Eliminate unit productions<br>UNITPAIRS = {(S,S),(A,A),(B,B),(B,A)}<blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><br><div>Since we have a unit pair, we want to get rid of the B-&gt;A by replacing A with all the RHS of production with A on the LHS</div><br><div>p2:</div><br><div>S-&gt;ASB|AB</div><div>A-&gt;aAS|aA|a</div><div>B-&gt;SbS|bS|Sb|b|aAS|aA|a|bb</div></blockquote><br><br><div>3: Eliminate useless symbols</div>GENERATING = {a,b,A,B,S}<div>REACHABLE &nbsp;= {S,A,B,a,b}</div><br>NO useless symbols, we're cleaned and ready for Chomskification<br><br><br><div>4. Convert to chromsky normal form:</div><br><div>C-&gt;a</div><div>D-&gt;b</div><br>A-&gt;CAS|CA|a<br><br><div>B-&gt;sDS|SD|SD|b|CAS|CA|a|DD</div><br>---<br><div>E-&gt;SB</div><br>S-&gt;AE<div>---</div><br><div>F-&gt;AS<br>G-&gt;DS</div>E-&gt;SB<br><br><div>C-&gt;a</div><div>D-&gt;b</div><br><div>S-&gt;AE|AB</div><div>A-&gt;CF|CA|a</div><div>B-&gt;SG|DS|SD|b|CF|CA|a|DD</div><br><div><b>FINALLY IN CHOMPSKY NORMAL FORM BIIIIIIIIAAAAAATTTTTTCCHHHHHHH!</b></div><br><div>---</div><br><div>CYK</div><br><div>aaab</div><table id="s3:d" width="580" border="1" cellpadding="3" cellspacing="0" height="120"><tbody><tr><td width="20%">a {A,B,C}</td><td width="20%">{S,A,B}<br></td><td width="20%">{F,S,A,B,E}<br></td><td width="20%"><br></td><td width="20%">if S ends up here, we can generate it!<br></td></tr><tr><td width="20%"><br></td><td width="20%">a {A,B,C}</td><td width="20%">{S,A,B}<br></td><td width="20%"><br></td><td width="20%"><br></td></tr><tr><td width="20%"><br></td><td width="20%"><br></td><td width="20%">a {A,B,C}</td><td width="20%">{S}<br></td><td width="20%"><br></td></tr><tr><td width="20%"><br></td><td width="20%"><br></td><td width="20%"><br></td><td width="20%">b {B,D}</td><td width="20%">{B}<br></td></tr><tr><td width="20%"><br></td><td width="20%"><br></td><td width="20%"><br></td><td width="20%"><br></td><td width="20%">b {B,D}</td></tr></tbody></table><br>COMPARE CLOSE VERTICALLY, FAR HORIZONTALLY<br><br><br>12 % 3 = 0<br><br><div>---</div><br><br><div>Arrange all productions, replace terminal on right with A<sub>a</sub></div><br><div>A<sub>a</sub>&nbsp;-&gt;a</div>B<sub>b</sub>&nbsp;-&gt;b<br><br><div>Replace the terminals with the new variables we just added</div><br>Basically adding extra variables to convert productions that go to 3 or more variables to variables replaces by 2 variables<br><br><br>-----<br><br><br><div>CNF cannot accept epsilon!</div><br><div>---</div><br><div><b>PUMPING LEMMA FOR CFLS</b></div><br><br><div>n = number of variables<br><br><div>Let
 L be e CFL. Then there exists a constant of the pumping lemma, n, such 
that if z is any string in L such that |z|&gt;=n, we can write z = 
uvwxy, subject to the following conditions:</div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div>|vwx| &lt;= n</div><div>wv != epsil - at least one of the strings pumped must not be empty</div><div>for all i&gt;=0, wv<sup>i</sup>wx<sup>i</sup>y is in L - the two substrings v and x may be pumped any number of times and the resulting string is still in L</div><br></blockquote><br><b>Example:</b></div><br><div>Show L= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>&nbsp;:
 n &gt;= 0 } is not context free by pumping lemma for CFLs &nbsp; &nbsp; &nbsp; &nbsp; &lt;-
 cannot be solved using a stack, keeping track of 3 counts, not 2 (2 is 
max for CFL)</div><br><font face="'Courier New'">1. Assume L is a CFL</font><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div><font face="'Courier New'">Then there exists a CFG G=(V,T,P,S) in CNF where |v| = m</font></div><div><font face="'Courier New'">Let n = n</font><sup><font face="'Courier New'">m</font></sup><font face="'Courier New'">&nbsp;be the constant for the pumping lemma</font></div></blockquote><br><div><font face="'Courier New'">2. Consider some z in L such that |z| &lt;= n<br></font></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div><font face="'Courier New'">z = a</font><sup><font face="'Courier New'">n</font></sup><font face="'Courier New'">b</font><sup><font face="'Courier New'">n</font></sup><font face="'Courier New'">c</font><sup><font face="'Courier New'">n &nbsp;</font></sup><font face="'Courier New'">is in L</font></div><div><font face="'Courier New'">|z| = 3n &gt;= n</font></div></blockquote><br><div><font face="'Courier New'">3. Let z = uvwxy where</font></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div><font face="'Courier New'">|vwx| &lt;= n</font></div><div><font face="'Courier New'">vx != epsil</font></div><br><br><div><font face="'Courier New'">&nbsp;&nbsp;{----n----}</font><font face="'courier new'">{----n---}</font><font face="'courier new'">{----n----}</font></div></blockquote><font face="'Courier New'">4. z = aaaaaa....abbbbbb...bcccccc...c</font><div><font face="'Courier New'">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; {--vwx---}</font></div><div><font face="'Courier New'">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {--vwx----}</font></div><br><div><font face="'Courier New'"><b>Note:</b> two subcases</font></div><br><div><font face="'Courier New'">a. vwx consists of same symbols (say a's)</font></div><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><div><font face="'Courier New'">then uv<sup>2</sup>wx<sup>2</sup>y is NOT in L since more a's than b's or c's</font></div><br></blockquote><font face="'Courier New'">b. vwx consists of different symbols (say a's and b's or b's and c's)</font><blockquote class="webkit-indent-blockquote" style="border: medium none; margin: 0pt 0pt 0pt 40px;"><font face="'courier new'">then uv<sup>2</sup>wx<sup>2</sup>y is NOT in L since counts are off or order is wrong</font></blockquote><br><br><div>-------</div><br><br><div>L = {ww<font size="2"><sup>R</sup></font>w : n is in {0,1}* }</div><br><div>001 100 001 is in L</div><div>---- ---- ----</div><br>z = 1<sup>n</sup>001<sup>n</sup>1<sup>n</sup>0 &nbsp;is in L<br><br><br><div>---------</div><br><br><b>Closure properties</b><br><br><div>CFLs are closed under the following operations:</div><ul><li>Union (or)</li><ul><li>S-&gt;A|B</li></ul><li>Concatenation (and)</li><ul><li>S-&gt;AB</li></ul><li>Closure (*) and positive Closure (+)</li></ul><br><br><div>â�� Closed under Reversal<br><br>â�� NOT closed under intersection -- the union of two CFLs is NOT guaranteed to be context free -- a<sup>n</sup>b<sup>n</sup>c<sup>n </sup>is an example<br><br>â�� L-R is a CFL (L is CFL, R is RL)</div><br><div>â�� Compliment of L (L BAR) is not guaranteed to be a CFL<br></div><br>â�� L-L is not guaranteed to be e CFL<br><br><div>---</div><br><br><div><b>CYK Algorithm - </b>for testing membership of strings in a context free language</div><b><br></b>Dynamic programming algorithm<br><br><div>Given a grammar G in CNF, and a string w of length n. Want to know if in polynomial time whether w is in L</div><br><b>Example:&nbsp;<br></b>Given the following productions of&nbsp;<div>S-&gt;AB|BC</div><div>A-&gt;BA|a</div><div>B-&gt;CC|b</div><div>C-&gt;AB|a</div><br><div>Test membership of baaba in L</div><br>---<br><br>TM Stuff in Jfap<br><br>~ = epsilon<br><br>!a = NOT a (anything but a)<br><br>Single check on tape input is last transition<br><br>Some
 predefined turing machine building blocks 
:http://www.ecst.csuchico.edu/~juliano/csci550/JFLAP/08_TuringMachines/building_blocks/library/<br><br>Movements: L/R/S<br><br>Multi tape turing machine has same power as single tape turing machine, takes same time.<br><br>NTM - doesn't make it more powerful<br><br>Instanataneous description:<br><br>[q<sub>1</sub>] ------0;X;R---&gt;[q<sub>2</sub>]<br><br>00q<sub>1</sub>011&nbsp; |-&nbsp;&nbsp;&nbsp; 00Xq<sub>2</sub>111<br><br>Jflap will use breadth first search when simulating non-determinism<br><br>Semi-infinite
 tape - means that there are no cells to the left of the initial head 
position. We basically fold an inifinite tape and end up with a two 
track infinite tape<br><br>A 2 or more stack tape machine will have the same power as a turing machine!<br>left
 stack is everything on the left of the RW header, right stack is 
everything on the right of the RW head. we just need to describe which 
stack we're on the top of.<br><br><b>Counter machine - </b>state based machine with a counter instead of a stack<br>The
 single stack parenthesis matching system is the same as using a counter
 that represents the size of the stack. We want it to be 0 when we're 
done, and it's cool.<br>Only operations on the counter are increment/decrement/test if 0<br><br>a 1 counter machine has the same power as a pda, and a two counter machine has the same power as a turing machine<br><br>Everything language accepted by a counter machine is a CFL<br><br>NOT CONTEXT FREE: L = {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> : n &gt; 0}<br><br>Turing machine for this would cross out first A, find the next B, cross it out, find the next C, cross it out.<br><br>Next homework will contain Stack machine to counter machine conversion! Will also be on final!<br><br>Represent stacks in Base X numbers, where X = cardinality of Gamma (characters in language)<br><br>S<sub>L</sub> would be tape to the left of the R/W head, S<sub>R</sub> would be tape to the right of the R/W head.<br><br>R = {a,b,c,X,B}<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 1,2,3,4,0<br><br>C1 = 4112<sub>5</sub><br>C2 = 33322<sub>5</sub><br>C3 = 2<sub>5</sub><br><br>Stack L = Xaab<br>Stack R = cccbb<br><br>// pop b, replace w/x<br>c1 /= 5<br>c1 *= 5<br>c1 += 4<br><br>// pop b from Stack R &amp; push into Stack L<br>c3 = c2 % 5<br>c2 /= 5<br>c1 *= 5<br>c1 += c3<br><br>Wednesday will have more clicker questions, we need to do the 10 pointer clikcer survey.<br><br><br><div>----</div><br>Transducer - when you're done, the turing machine's read write head must be on the first number of the output<br><br><div>Use multiple tapes and building blocks!</div><br>For Homework 11:<div>For #1a, if input is a, output should be aaaaa</div><br>Recursive language - turing decidable language, guaranteed to halt, will half on state Yes or state No<br><br>Show regular languages are contained in recursive languages by comparing machines that recognize one or the other<div>Then provide one recursive language that's not regular<br><br><br></div>--<br><br><div>TMs are closed under union (or the set of recursively enumerable languages)<br><br></div><div>TMs are closed under intersection (or the set of recursively enumerable languages)<br></div><br><div>TMs are closed under concatenation (or the set of recursively enumerable languages)<br></div><br>PDAs can recognize regular languages<div>The set of recursive languages is properly contained in the set of recursivel enumerable languages</div><br>---<br><br><div>How to encode a turing machine</div><br>Step 1a:<br><div>Start state is always state 1<br>Assign integers to all the states<br><br><div>Step 1b:</div><div>Assign integers to the tape symbols</div><br><div>Step 1c:</div><div>Assigns 3 integers to LEFT, RIGHT, and STAY</div><br>Step 2:</div><div>Encode the transition function with 0<sup>i</sup>10<sup>j</sup>10<sup>k</sup>10<sup>l</sup>10<sup>m</sup><br><br>Step 3:</div><div>Encode the input string</div>Separate with 111, encode using the assigned symbols from step 1b<br><br><br><div>example:</div><br><div>w = 000111</div><br><div>TM, A = (Q={0,1,2,3,4}, E = {0,1}, R = E U {X,Y,B}, DELTA = see figure, q<font size="2"><sub>0</sub>&nbsp;= 0, B, F = { q<sub>4</sub>} )</font></div><font size="3"><br></font><font size="3">Integers for the states:</font><div><font size="3">1 = q<sub>0</sub></font></div><font size="3">3 = q<sub>1</sub></font><div><sub><font size="3">4 = q2</font></sub></div><font size="3">5 = q<sub>3</sub></font><div><sub><font size="3">2 = q4</font></sub></div><sub><br><br></sub><div>0 = 2</div><div>1 = 3</div><div>X = 4</div><div>Y = 5</div><div>B = 1</div><br><div>L = 1</div><div>R = 2</div><div>S = 3</div><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (cur, read, end, write, direction)<br><div>For q0 to q2 transition = (0,0,2,Y,R)</div><div>Encoded: 01001000100000100&nbsp;&nbsp; &nbsp;11 &lt;-separator</div><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (cur, read, end, write, direction)<br><div>For q0 to q1 transition = (0,1,1,X,R)</div><div>Encoded: 010010010000100&nbsp;&nbsp; &nbsp;11 &lt;-separator</div><br><div>+ 9 transitions</div><br><div>111 &lt;- separator</div><br><div>000111</div><br><br><div>ASSIGN FINAL STATE TO INTEGER 2</div><div>ASSIGN START STATE TO INTEGER 1</div><br><br>--<br><br><br><div><b>Test Monday</b></div><br><div>Starts from minimization</div><br><div><b>State partitioning</b></div><br><div>LEFT = final</div><div>RIGHT = non-final</div><br><div>Leaves represent the states for the minimized DFA</div><br>CFGs, PDAs, conversion between one and the other<br><br><div>Chompskification &amp; Normalization for CFGs<br>&nbsp;&nbsp; &nbsp;he lists the steps and the order on exam<br></div><br><div>pumping lemma for CFG languages</div><br><div>recursive languages</div><div>recursively enumerable language</div><div>turing machines</div><br><div>Proving questions etc</div><br><div>Most questions are algorithmic</div><br><div><b>Review</b></div><div>Review with sample examples on author's website</div><br>Bring book and samples<br><br><div>Restricted turing machine</div><ul><li>finite tape</li></ul><br>Turing
 machine for regular language doesn't write to the tape, just reads. 
SHould look same as finite state machine, but the labels will change.<br><br>Problem like number 6 on the exam......<br><br><br><div><b>For two stack machines:</b></div><div>TOP OF LEFT STACK IS WHAT"S ON THE BOTTOM OF THE RW HEAD</div><br><div>Read stacks from the bottom up</div><br><br><br><br>

